#+TITLE:  _=scipy=_ : librairie pour la programmation scientifique
#+AUTHOR: Xavier Garrido
#+DATE:   13/04/2017
#+OPTIONS: toc:nil ^:{} author:nil
#+STARTUP:     beamer
#+LATEX_CLASS: python-slide

* =scipy= ?

- Le module =scipy= vise à unifier et fédérer un ensemble de bibliothèques Python
  à usage scientifique

- =scipy= s'appuie sur =numpy= en utilisant les objets de type tableaux et fournit
  des algorithmes scientifiques optimisés :

  #+ATTR_BEAMER: :overlay +-
  - Fonctions spéciales (fonction de Bessel, loi de distribution,...)
  - Algorithmes d'intégration, d'interpolation et d'optimisation
  - Algèbre linéaire (résolution équations linéaires, valeurs/vecteur propres)
  - Traitement du signal et des images (transformé de Fourier, convolution,...)

* Installation & importation de =scipy=

#+ATTR_BEAMER: :overlay +-
- Installation /via/ =pip=
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC shell-session
    $ pip install scipy
  #+END_SRC

- Convention d'importation : l'ensemble des modules =scipy= peuvent être importés
  individuellement
  #+BEAMER: \vskip+5pt
  #+BEGIN_SRC python
    In [1]: import scipy.linalg as linalg
  #+END_SRC

* *=scipy.special=* : fonctions spéciales

- Fonctions de Bessel :
  $x^2\frac{\text{d}^2y}{\text{d}x^2}+x\frac{\text{d}y}{\text{d}x}+(x^2-\alpha^2)y=0$

  - Fonctions de Bessel de première espèce $J_n$
  - Fonctions de Bessel de seconde espèce $Y_n$

** Python code
:PROPERTIES:
:BEAMER_COL: 0.55
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: from scipy.special import jn, yn

  In [2]: x = np.linspace(0, 10, 100)
  In [3]: for n in range(4):
     ...:     plt.plot(x, jn(n, x), label=r"$J_%d(x)$" % n)
  In [4]: plt.legend()
  #+END_SRC

#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [5]: for n in range(4):
     ...:     plt.plot(x, yn(n, x), label=r"$Y_%d(x)$" % n)
  In [6]: plt.legend()
#+END_SRC

- Pour découvrir l'ensemble des [[https://docs.scipy.org/doc/scipy/reference/special.html][fonctions spéciales]] offertes par =scipy=

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [7]: from scipy import special
  In [8]: special?
#+END_SRC

** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/scipy_jn.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/scipy_yn.pdf}
  \end{center}
#+END_SRC
* *=scipy.integrate=* : intégration de fonctions

- L'intégration numérique de $\int_a^bf(x)\text{d}x$ peut se faire /via/ le module
  =scipy.integrate= :
  - *=quad=* calcule une intégrale simple
  - *=dblquad=* calcule une intégrale double
  - *=tplquad=* calcule une intégrale triple
  - *=nquad=* calcule une intégrale à $n$ dimensions

#+BEAMER: \pause

- Exemple $\int_{-\infty}^{+\infty}\exp(-x^2)\text{d}x = \sqrt\pi$
  #+BEAMER: \vskip+5pt
  #+BEGIN_SRC python
    In [1]: import scipy.integrate as integrate

    In [2]: val, abserr = integrate.quad(lambda x : np.exp(-x**2), -np.inf, +np.inf)
    In [3]: print("I =", val, "+/-", abserr)
    I = 1.7724538509055159 +/- 1.4202636780944923e-08
  #+END_SRC

* *=scipy.integrate=* : intégration de fonctions

- Exemple d'intégration avec passage de paramètre : $I(a,b)=\int_{0}^{1}(ax^2+b)\text{d}x$
  #+BEAMER: \vskip+5pt
  #+BEGIN_SRC python
    In [1]: import scipy.integrate as integrate

    In [2]: def integrand(x, a, b):
       ...:     return a*x**2+b
    In [3]: a = 2
    In [4]: b = 1
    In [5]: integrate.quad(integrand, 0, 1, args=(a, b))
    Out[7]: (1.6666666666666667, 1.8503717077085944e-14)
  #+END_SRC

* *=scipy.integrate=* : intégration de fonctions

- Exemple d'intégrale multiple
  #+BEGIN_SRC latex
    \begin{align*}
      I_n=\int_0^\infty\int_1^\infty\frac{e^{-xt}}{t^n}\text{d}t\text{d}x=\frac{1}{n}
    \end{align*}
  #+END_SRC

  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In [1]: def I(n):
       ...:     from scipy.integrate import dblquad
       ...:     return dblquad(lambda t, x: np.exp(-x*t)/t**n, 0, np.inf, lambda x: 1, lambda x: np.inf)

    In [2]: I(4)[0], I(4)[0]-1/4
    Out[2]: (0.2500000000043577, 4.357680882804971e-12)

    In [3]: I(100)[0], I(100)[0]-1/100
    Out[3]: (0.010000000000118046, 1.1804619781674575e-13)
  #+END_SRC

  #+BEAMER: \pause\vskip-1pt
  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In [4]: def I(n):
       ...:     from scipy.integrate import nquad
       ...:     return nquad(lambda t, x: np.exp(-x*t)/t**n, [[1, np.inf], [0, np.inf]])
  #+END_SRC
* *=scipy.integrate=* : résolution d'équations différentielles ordinaires

#+ATTR_BEAMER: :overlay +-
- =scipy= fournit l'interface *=odeint=* pour résoudre les EDO en plus de l'interface
  =ode=, plus complète mais plus subtile

- Une équation différentielle ordinaire peut s'écrire sous la forme *$y'=f(y, t)$*
  où *$y = [y_1(t), y_2(t),\ldots, y_n(t)]$* et *$f$ est une fonction fournissant
  les dérivées des fonctions $y_i(t)$*

- La résolution /via/ la fonction =odeint= implique la connaissance de $f$ et des
  conditions initiales $y(0)$

  #+BEAMER: \vskip+5pt
  #+BEGIN_SRC python
    y_t = odeint(f, y_0, t)
  #+END_SRC
  #+BEAMER: \vskip+5pt

  où =t= est un vecteur =numpy= correspondant à l'échantillonnage en temps et =y_t=
  contient, en chaque temps =t=, une colonne pour chaque solution $y_i(t)$

* *=scipy.integrate=* : résolution d'équations différentielles ordinaires
#+BEAMER: \framesubtitle{\href{http://en.wikipedia.org/wiki/Double_pendulum}{Mouvement du double pendule}}

** Equations
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{align*}
    \dot{\theta}_1&=\frac{6}{m\ell^2}\times\frac{2p_{\theta_1}-3\cos(\theta_1-\theta_2)p_{\theta_2}}{16-9\cos^2(\theta_1-\theta_2)}\\
    \dot{\theta}_2&=\frac{6}{m\ell^2}\times\frac{8p_{\theta_2}-3\cos(\theta_1-\theta_2)p_{\theta_1}}{16-9\cos^2(\theta_1-\theta_2)}\\
    \dot{p}_{\theta_1}&=-\frac{1}{2}m\ell^2\left[\dot{\theta}_1\dot{\theta}_2\sin(\theta_1-\theta_2)+3\frac{g}{\ell}\sin\theta_1\right]\\
    \dot{p}_{\theta_2}&=-\frac{1}{2}m\ell^2\left[-\dot{\theta}_1\dot{\theta}_2\sin(\theta_1-\theta_2)+\frac{g}{\ell}\sin\theta_2\right]
  \end{align*}
#+END_SRC

où $p_{\theta_i}$ sont les impulsions des barycentres $(x_1, y_1)$ et $(x_2,
y_2)$.

On pose $y=[\theta_1,\theta_2,p_{\theta_1},p_{\theta_2}]$


** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

[[file:figures/dbl_pendulum.pdf]]
* *=scipy.integrate=* : résolution d'équations différentielles ordinaires
#+BEAMER: \framesubtitle{\href{http://en.wikipedia.org/wiki/Double_pendulum}{Mouvement du double pendule}}

#+BEAMER: \scriptsize
#+BEGIN_SRC latex
  \begin{align*}
    \dot{y}_1&=\frac{6}{m\ell^2}\times\frac{2y_3-3\cos(y_1-y_2)y_4}{16-9\cos^2(y_1-y_2)}\\
    \dot{y}_2&=\frac{6}{m\ell^2}\times\frac{8y_4-3\cos(y_1-y_2)y_3}{16-9\cos^2(y_1-y_2)}\\
    \dot{y}_3&=-\frac{1}{2}m\ell^2\left[\dot{y}_1\dot{y}_2\sin(y_1-y_2)+3\frac{g}{\ell}\sin y_1\right]\\
    \dot{y}_4&=-\frac{1}{2}m\ell^2\left[-\dot{y}_1\dot{y}_2\sin(y_1-y_2)+\frac{g}{\ell}\sin y_2\right]\\
  \end{align*}
#+END_SRC

#+BEAMER: \pause

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: def dy(y, t):
     ...:     g, l, m = 9.82, 0.5, 0.1
     ...:     y1, y2, y3, y4 = y[0], y[1], y[2], y[3]
     ...:
     ...:     dy1 = 6.0/m/l**2*(2*y3 - 3*np.cos(y1-y2)*y4)/(16 - 9*np.cos(y1-y2)**2)
     ...:     dy2 = 6.0/m/l**2*(8*y4 - 3*np.cos(y1-y2)*y3)/(16 - 9*np.cos(y1-y2)**2)
     ...:     dy3 = -0.5*m*l**2*(+dy1*dy2*np.sin(y1-y2) + 3*(g/l)*np.sin(y1))
     ...:     dy4 = -0.5*m*l**2*(-dy1*dy2*np.sin(y1-y2) + 1*(g/l)*np.sin(y2))
     ...:
     ...:     return [dy1, dy2, dy3, dy4]
#+END_SRC

* *=scipy.integrate=* : résolution d'équations différentielles ordinaires
#+BEAMER: \framesubtitle{\href{http://en.wikipedia.org/wiki/Double_pendulum}{Mouvement du double pendule}}

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: g, l, m = 9.82, 0.5, 0.1
  In [2]: def dy(y, t):
     ...:     y1, y2, y3, y4 = y[0], y[1], y[2], y[3]
     ...:
     ...:     dy1 = 6.0/m/l**2*(2*y3 - 3*np.cos(y1-y2)*y4)/(16 - 9*np.cos(y1-y2)**2)
     ...:     dy2 = 6.0/m/l**2*(8*y4 - 3*np.cos(y1-y2)*y3)/(16 - 9*np.cos(y1-y2)**2)
     ...:     dy3 = -0.5*m*l**2*(+dy1*dy2*np.sin(y1-y2) + 3*(g/l)*np.sin(y1))
     ...:     dy4 = -0.5*m*l**2*(-dy1*dy2*np.sin(y1-y2) + 1*(g/l)*np.sin(y2))
     ...:
     ...:     return [dy1, dy2, dy3, dy4]
#+END_SRC

#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [2]: # Conditions initiales
  In [3]: y0 = [np.pi/4, np.pi/2, 0, 0]

  In [4]: # Échantilonnage du temps
  In [5]: t = np.linspace(0, 10, 250)

  In [6]: # Résolution des équations différentielles
  In [7]: from scipy.integrate import odeint
  In [8]: y = odeint(dy, y0, t)
#+END_SRC

* *=scipy.integrate=* : résolution d'équations différentielles ordinaires
#+BEAMER: \framesubtitle{\href{http://en.wikipedia.org/wiki/Double_pendulum}{Mouvement du double pendule}}

** Python
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [9]: t1, t2 = y[:, 0], y[:, 1]
  In [10]: fig, ax = plt.subplots(2, 1, figsize=(5,7))
  In [11]: ax[0].plot(t, t1, label=r"$\theta_1$")
  In [12]: ax[0].plot(t, t2, label=r"$\theta_2$")
  In [13]: ax[0].set(xlabel=r"$t$ [s]",
                     ylabel=r"$\theta$ [rad]")
  In [14]: ax[0].legend()

  In [15]: x1, y1 = l*np.sin(t1), -l*np.cos(t1)
  In [16]: x2, y2 = x1 + l*np.sin(t2), y1 - l*np.cos(t2)
  In [17]: ax[1].plot(x1, y1, label=r"$(x_1, y_1)$")
  In [18]: ax[1].plot(x2, y2, label=r"$(x_2, y_2)$")
  In [19]: ax[1].set(xlabel=r"$x$", ylabel=r"$y$")
  In [20]: ax[1].legend()
#+END_SRC

** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

[[file:figures/scipy_dbl_pendulum1.pdf]]

* *=scipy.integrate=* : résolution d'équations différentielles ordinaires
#+BEAMER: \framesubtitle{\href{http://en.wikipedia.org/wiki/Double_pendulum}{Mouvement du double pendule}}

** Python
:PROPERTIES:
:BEAMER_COL: 0.6
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python -n
  fig = plt.figure()
  ax = fig.add_subplot(111, autoscale_on=False,
                       xlim=(-1, 1), ylim=(-1.2, 0.2))
  ax.grid()

  pendule, = ax.plot([], [], "ok-", lw=2)
  mvt1, = ax.plot([], [], c="C0")
  mvt2, = ax.plot([], [], c="C1")
  text = ax.text(0.05, 0.9, "", transform=ax.transAxes)

  def animate(i):
      thisx = [0, x1[i], x2[i]]
      thisy = [0, y1[i], y2[i]]

      pendule.set_data(thisx, thisy)
      mvt1.set_data(x1[:i], y1[:i])
      mvt2.set_data(x2[:i], y2[:i])
      text.set_text("temps = %.1f s" % (i*0.04))
      return pendule, mvt1, mvt2, text

  ani = animation.FuncAnimation(fig, animate, np.arange(1, len(y)),
                                interval=25, blit=True)
  ani.save("double_pendulum.mp4", fps=15)
#+END_SRC

** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \animategraphics[autoplay,loop, width=\linewidth]{50}{pendulum/pendulum}{001}{249}
#+END_SRC
* *=scipy.integrate=* : résolution d'équations différentielles ordinaires
#+BEAMER: \framesubtitle{\href{http://en.wikipedia.org/wiki/Damping}{Oscillateur harmonique amorti}}

#+BEGIN_SRC latex
  \begin{align*}
    \frac{\text{d}^2x}{\text{d}t^2}+2\zeta\omega_0\frac{\text{d}x}{\text{d}t}+\omega_0^2x=0
  \end{align*}
#+END_SRC


** Python
:PROPERTIES:
:BEAMER_COL: 0.6
:END:

#+BEAMER: \scriptsize
- On pose $p = \frac{\text{d}x}{\text{d}t}$
  #+BEGIN_SRC latex
    \begin{align*}
      \frac{\text{d}p}{\text{d}t}&=-2\zeta\omega_0p-\omega_0^2x\\
      \frac{\text{d}x}{\text{d}t}&=p
    \end{align*}
  #+END_SRC

#+BEAMER: \pause

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: def dy(y, t, zeta, w0):
     ...:     x, p = y[0], y[1]
     ...:
     ...:     dx = p
     ...:     dp = -2 * zeta * w0 * p - w0**2 * x
     ...:     return [dx, dp]
  In [2]: y0 = [1.0, 0.0]
  In [3]: t = np.linspace(0, 10, 1000)
  In [4]: w0 = 2*np.pi*1.0
  In [5]: from scipy.integrate import odeint
  In [6]: y1 = odeint(dy, y0, t, args=(0.0, w0))
  In [7]: y2 = odeint(dy, y0, t, args=(0.2, w0))
  In [8]: y3 = odeint(dy, y0, t, args=(1.0, w0))
  In [9]: y4 = odeint(dy, y0, t, args=(5.0, w0))
#+END_SRC

** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<3>[width=1.1\linewidth]{figures/scipy_oha.pdf}
  \end{center}
#+END_SRC
* *=scipy.interpolate=* : interpolation numérique
** Python
:PROPERTIES:
:BEAMER_COL: 0.6
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: def f(x):
     ...:     return np.sin(x)

  In [2]: n = np.arange(0, 10)
  In [3]: y_meas = f(n) + 0.1*np.random.randn(n.size)
#+END_SRC

#+BEAMER: \pause\pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [4]: from scipy.interpolate import interp1d
  In [5]: linear_interpolation = interp1d.(n, y_meas)
  In [6]: yinterp1 = linear_interpolation(np.linspace(0, 9, 100))
#+END_SRC

#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [7]: cubic_interpolation = interp1d.(n, y_meas, kind="cubic")
  In [8]: yinterp2 = cubic_interpolation(np.linspace(0, 9, 100))
#+END_SRC

** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/scipy_interpolation0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/scipy_interpolation1.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/scipy_interpolation2.pdf}
    \includegraphics<4>[width=1.1\linewidth]{figures/scipy_interpolation3.pdf}
  \end{center}
#+END_SRC
