#+TITLE:  _=numpy=_ : librairie pour le calcul scientifique
#+AUTHOR: Xavier Garrido
#+DATE:   15/02/2017
#+OPTIONS: toc:nil ^:{} author:nil
#+STARTUP:     beamer
#+LATEX_CLASS: python-slide

* =numpy= ?

- Le module =numpy= est l'outil de base utilisé dans tous calculs scientifiques et
  donc numériques en Python

- =numpy= fournit en particulier des objets de type *vecteurs, matrices et plus
  généralement tableaux à $n$ dimensions*

- =numpy= facilite et *optimise[fn:e0eb780c73d6562]* les opérations de *stockage et
  de manipulation* des données *numériques* notamment lorsque la taille des
  tableaux devient importante \to /array oriented computing/

#+BEAMER: \pause
- Convention d'importation
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: import numpy as np
  #+END_SRC

* Création de vecteurs, matrices

- À partir d'une liste de valeurs
  #+ATTR_BEAMER: :overlay +-
  - Vecteur
    #+BEAMER: \vskip5pt
    #+BEGIN_SRC python
      In [2]: v = np.array([0, 1, 2, 3])
      In [3]: v
      Out[3]: array([0, 1, 2, 3])
    #+END_SRC
    #+BEAMER: \vskip5pt

  - Matrice 2\times2
    #+BEAMER: \vskip5pt
    #+BEGIN_SRC python
      In [4]: M = np.array([[0, 1], [2, 3]])
      In [5]: M
      Out[5]:
      array([[0, 1],
             [2, 3]])
    #+END_SRC

    #+BEAMER: \pause\vskip5pt
    #+BEGIN_SRC python
      In [6]: type(v), type(M)
      Out[6]: (numpy.ndarray, numpy.ndarray)

      In [7]: v.ndim, M.ndim
      Out[7]: (1, 2)

      In [8]: v.shape, M.shape
      Out[8]: ((4,), (2, 2))
    #+END_SRC


* Pourquoi =numpy= ?

- Les objets de type =numpy.ndarray= \equiv à une liste Python (ou liste de
  listes)

- *Pourquoi ne pas simplement utiliser les listes Python pour les calculs au
  lieu de créer un nouveau type de tableau ?*

* Pourquoi =numpy= ?

Il existe plusieurs (très bonnes) raisons à cela:

#+ATTR_BEAMER: :overlay +-
- Les listes Python sont très générales (on parle également d'objet de haut
  niveau). *Elles peuvent contenir n'importe quel objet \to typage
  dynamique*. Elles ne supportent pas les fonctions mathématiques.

- Les tableaux ou /array/ de =numpy= sont *statiquement typées et homogènes*

  - Le type des éléments est déterminé lorsque le tableau est créé *\to plus de
    typage dynamique*
  - De même la taille du tableau est fixée à la création *\to stockage en
    mémoire optimisée*

- En raison du typage statique, les fonctions mathématiques telles que la
  multiplication et l'addition de matrices peuvent être mises en œuvre /via/ un
  langage compilé (C et Fortran)

#+BEGIN_COMMENT
So far the numpy.ndarray looks awefully much like a Python list (or nested list). Why not simply use Python lists for computations instead of creating a new array type?

There are several reasons:

- Python lists are very general. They can contain any kind of object. They are
  dynamically typed. They do not support mathematical functions such as matrix
  and dot multiplications, etc. Implementing such functions for Python lists
  would not be very efficient because of the dynamic typing.
- Numpy arrays are statically typed and homogeneous. The type of the elements is
  determined when the array is created.
- Numpy arrays are memory efficient.
- Because of the static typing, fast implementation of mathematical functions
  such as multiplication and addition of numpy arrays can be implemented in a
  compiled language (C and Fortran is used).

http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-2-Numpy.ipynb#From-lists

http://www.scipy-lectures.org/intro/numpy/array_object.html#numpy-arrays

#+END_COMMENT

* Pourquoi =numpy= ?

- Démonstration
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: %timeit [i**2 for i in range(1000)]
    1000 loops, best of 3: 403 us per loop
  #+END_SRC

  #+BEAMER: \pause\vskip5pt
  #+BEGIN_SRC python
    In [3]: a = np.arange(1000)
    In [4]: %timeit a**2
    100000 loops, best of 3: 12.7 us per loop
  #+END_SRC

* =numpy= reference documentation

http://www.scipy-lectures.org/intro/numpy/array_object.html#numpy-arrays

* creating arrays

http://www.scipy-lectures.org/intro/numpy/array_object.html#creating-arrays

http://www.scipy-lectures.org/intro/numpy/array_object.html#creating-arrays

** linspace logspace

https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html

http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-2-Numpy.ipynb#linspace-and-logspace

* Indexing and slicing

Quite similar to Python list

http://www.scipy-lectures.org/intro/numpy/array_object.html#indexing-and-slicing

http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/02.02-The-Basics-Of-NumPy-Arrays.ipynb#Array-Slicing:-Accessing-Subarrays
* Copies & views

http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/02.02-The-Basics-Of-NumPy-Arrays.ipynb#Subarrays-as-no-copy-views
http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/02.02-The-Basics-Of-NumPy-Arrays.ipynb#Creating-copies-of-arrays
http://www.scipy-lectures.org/intro/numpy/array_object.html#copies-and-views

* Ufuncs

http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/02.03-Computation-on-arrays-ufuncs.ipynb#Array-arithmetic

* Min, max, sum, stat

http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/02.04-Computation-on-arrays-aggregates.ipynb

* Footnotes

[fn:e0eb780c73d6562] les principales fonctions de =numpy= sont implémentées en C
et en Fortran
